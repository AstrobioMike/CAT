#!/usr/bin/env python3

import csv
import subprocess
import sys
import re


#Paths to diamond and prodigal binaries should be absolute, for taxonomy tree files path can be relative.
diamond = '/absolute/path/to/executables/of/diamond'
prodigal = '/absolute/path/to/executables/of/prodigal'
path_to_taxonomy_files="/path/to/files/folder/"



error_message=" \n \
Description: cat is a pipeline for robust taxonomic classification of long sequences. \n\n \
Usage: \n\n \
cat <input option(s)> <input file(s)> --prefix <uniq ID> [OTHER OPTIONS] \n\n \
Input options: \n\n \
Option 1: Including ORF prediction, alignment and sequence classification \n\n\
\t -f \t FASTA_file.fna \t File with long sequences [nucleotides] \n\
\t -db \t diamond_database.dmnd \t Database with reference sequences. \n\n \
Option 2: Including alignment and sequence classification \n\n\
\t -faa \t FASTA_file.faa \t File with predicted proteins [proteins] \n\n \
\t -db \t diamond_database.dmnd \t Database with reference sequences. \n\n \
Option 3: Including sequence classification only.\n\n\
\t -d \t diamond_file \t File with alignment [m8] \n\n \
Other options: \n\n \
-gff \t gff_file \t Providing in the output file total number of predicted ORFs. Can be used with -faa and -d input options only \n \
-b1 \t bitscore 1 [0-100] \t High bound of percentage range of top hits for classification of individual ORFs (Default:10) \n \
-b2 \t bitscore 2 [0-1] \t Threshold of the maximum achievable bitscore for the contig (Defaul:0.5)\n \
-qual \t bitscore 3 [0-] \t Minimal alignment quality (bitscore value) which can be used in classification (Default:0) \n \
-h \t Print this message" 

mode = 0
if len(sys.argv) < 2:
  print(error_message)
  sys.exit() 

if '-prefix' in sys.argv:
    prefix = sys.argv[(sys.argv).index("-prefix")+1]
else:
    print(error_message)
    sys.exit()
    
if "-h" in sys.argv:
  print(error_message)
  sys.exit()

if "-d" in sys.argv:
    diamond_file=sys.argv[(sys.argv).index("-d")+1]
    
    mode = 2
elif "-f" in sys.argv and "-d" not in sys.argv and '-faa' not in sys.argv:
    if '-db' in sys.argv:
        database_name=sys.argv[(sys.argv).index("-db")+1]
        database = re.search('(.*)\.dmnd', database_name).group(1)    
        fasta=sys.argv[(sys.argv).index("-f")+1]
        diamond_file = prefix + '_alignment_diamond'
        protein_fasta = prefix + '_predicted_prot.faa'
    else:
        print('Database file missing')
        sys.exit()

elif '-faa' in sys.argv and "-d" not in sys.argv:
    if '-db' in sys.argv:
        protein_fasta=sys.argv[(sys.argv).index("-faa")+1]
        database_name=sys.argv[(sys.argv).index("-db")+1]
        database = re.search('(.*)\.dmnd', database_name).group(1)
        diamond_file = prefix + '_alignment_diamond'
        mode = 1    
    else:
        print('Database file missing')
        sys.exit()
else:    
    print("Input fasta file missing")
    print(error_message)
    sys.exit()

if "-b1" in sys.argv:
  b1=sys.argv[(sys.argv).index("-b1")+1]
  cust_bit_thresh=1 - float(b1)/float(100)
else:
  cust_bit_thresh=0.9

if "-b2" in sys.argv:
  cont_bitscore=float(sys.argv[(sys.argv).index("-b2")+1])
else:
  cont_bitscore=0.5

if '-gff' in sys.argv:
    protein_gff=sys.argv[(sys.argv).index("-gff")+1]
    mode_gff = 1
else:
    mode_gff = 0

if '-qual' in sys.argv:
    qual_threshold=float(sys.argv[(sys.argv).index("-qual")+1])
else:
    qual_threshold = 0

if mode == 0:
    print('Predicting ORFs')
    protein_gff = prefix + '_orfs.gff'
    subprocess.call([prodigal, '-i', fasta, '-a', protein_fasta, '-o', protein_gff, '-p', 'meta', '-q', '-f', 'gff'])
    mode_gff = 1
    print('Aligning')
    subprocess.call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '--sensitive', '-o', diamond_file, '--quiet'])
elif mode == 1:
    print('Aligning')
    subprocess.call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '--sensitive', '-o', diamond_file, '--quiet'])
elif mode == 2:     
    pass


categories2 = ["superkingdom","phylum","class","order","family","genus","species"]
categories = ["species", "genus", "family", "order", "class", "phylum", "superkingdom", 'root']

names_dict = {}
rank_dict = {}
parent_dict = {}
with open(path_to_taxonomy_files + 'names.dmp') as names_file:
    names = csv.reader(names_file,delimiter='\t',quoting=csv.QUOTE_NONE)     
    for line in names:
        if line[6] == 'scientific name':
            names_dict[line[0]] = line[2]

with open(path_to_taxonomy_files + 'nodes.dmp','r')as nodes_file:
    nodes = csv.reader(nodes_file,delimiter='\t',quoting=csv.QUOTE_NONE)
    for line in nodes:
        parent_dict[line[0]] = line[2]
        rank_dict[line[0]] = line[4]

def parse_nodes(taxid, data_dict):
    if taxid in parent_dict and taxid in rank_dict:
        while parent_dict[taxid] != taxid:
            data_dict[rank_dict[taxid]] = taxid + '_' + names_dict[taxid]
            taxid = parent_dict[taxid]
    else:
          data_dict = {}  
    return(data_dict)

print('Parsing diamond alignment')
contigs_names = set()
main_dict = {}
with open(diamond_file) as file_1:
    alignment=csv.reader(file_1,delimiter='\t')
    taxonomy = {}
    for line in alignment:
        contig_name = re.search('(.*)_\d+$', line[0]).group(1)
        gene_name = line[0]
        contigs_names.add(contig_name)
        without_version = re.search('^(.+?)(?=(\.|:|$))', line[1]).group(1)
        if without_version not in taxonomy:
            taxonomy[without_version] = {}
        if contig_name not in main_dict:
            main_dict[contig_name] = {}   
        if gene_name not in main_dict[contig_name] and float(line[-1]) > qual_threshold:
            main_dict[contig_name][gene_name] = {}
            main_dict[contig_name][gene_name]['accessions'] = [without_version]
            main_dict[contig_name][gene_name]['bitscores'] = [float(line[-1])]
            bit_threshold = float(line[-1]) * cust_bit_thresh
        elif gene_name in main_dict[contig_name] and float(line[-1]) > bit_threshold and float(line[-1]) > qual_threshold:            
            main_dict[contig_name][gene_name]['accessions'].append(without_version)
            main_dict[contig_name][gene_name]['bitscores'].append(float(line[-1]))

#Collecting information about number of predicted ORFs
if mode_gff == 1:
    gff = {}
    content = []
    with open(protein_gff) as file1:
        gff_file=csv.reader(file1,delimiter='\t',quoting=csv.QUOTE_NONE)
        for line in gff_file:
            content.append(line[0])
    for name in contigs_names:    
        gff[name] = content.count(name)


total = []
print('Parsing prot.accession2taxid file')	
with open(path_to_taxonomy_files + 'prot.accession2taxid') as file1:
    acc_tax_csv=csv.reader(file1,delimiter='\t',quoting=csv.QUOTE_NONE)
    for line in acc_tax_csv:
        
        if line[0] != 'accession':
            if line[0] in taxonomy:
                z = parse_nodes(line[2], {})
                if z:
                    for cat in categories:
                        if cat in z.keys():
                            taxonomy[line[0]][cat] = z[cat] 
                        else:
                            taxonomy[line[0]][cat] = 'NA'
                else:
                    for cat in categories:
                        taxonomy[line[0]][cat] = 'NA'
                taxonomy[line[0]]['root'] = '131567_cellular organisms'


#The function evaluates level of taxonomic annotation for N% top hits for a gene to exclude bitscores 
#of low-level annotations and retain it in case of accidental absence of annotation

#For example "species", "genus", "family", "order", "class", "phylum", "superkingdom"
#               exist    exist       NA     exist    exist    exist     exist
#bitscore for NA will be accounted
#For example "species", "genus", "family", "order", "class", "phylum", "superkingdom"
#               NA        NA       NA       exist     exist    exist     exist
#In this case bitscores for NA will be excluded

def evaluation(acc, index, bitscore, gene_dict, flag):
    if index < 8:
        if taxonomy[acc][categories[index]] == 'NA' and flag == 0:
            gene_dict[categories[index]] = 0
            index += 1
            return(evaluation(acc, index, bitscore, gene_dict, flag))
        elif taxonomy[acc][categories[index]] == 'NA' and flag == 1:
            gene_dict[categories[index]] = bitscore
            index += 1
            return(evaluation(acc, index, bitscore, gene_dict, flag))   
        else:
            gene_dict[categories[index]] = bitscore
            index += 1
            flag = 1 
            return(evaluation(acc, index, bitscore, gene_dict, flag))   
    else:
        return(gene_dict)


#Same function as previous, but for analysis of gene annotation after identification of LCA
def evaluation2(genes, index, gene_dict, flag):
    if index < 8:
        if genes[categories[index]] == 'NA' and flag == 0:
            gene_dict[categories[index]] = 0
            index += 1
            return(evaluation2(genes, index, gene_dict, flag))
        elif genes[categories[index]] == 'NA' and flag == 1:
            gene_dict[categories[index]] = 1
            index += 1
            return(evaluation2(genes, index, gene_dict, flag)) 
        else:
            gene_dict[categories[index]] = 1
            index += 1
            flag = 1 
            return(evaluation2(genes, index, gene_dict, flag))   
    else:
        return(gene_dict)

#Identification of LCA for N% of top hits
def calculation(eval_dict):
    lca = ''   
    t = []
    loc_dict = {}
    for cat in categories:
        if [taxonomy[item][cat] for item in eval_dict if eval_dict[item][cat] != 0]:
            l, num = zip(*[(taxonomy[item][cat], item) for item in eval_dict if eval_dict[item][cat] != 0]) 
            if len(set(l)) == 1:
                lca  = cat
                b = [eval_dict[item][cat] for item in eval_dict if eval_dict[item][cat] != 0]
                bitscore = sum(b) / len(num)
                break
    if not lca:
        for z in eval_dict:
            print(taxonomy[z])         
    for i in range(8):
        if i >= categories.index(lca):
            loc_dict[categories[i]] = taxonomy[num[0]][categories[i]]
        else:
            loc_dict[categories[i]] = 'NA'    
    loc_dict["bitscore"] = bitscore    
    return(loc_dict)

#Main function, contig classification for threshold >= 50%         
def classification_50(contig_dict):
    eval_dict = {}
    for gene in contig_dict:        
        eval_dict[gene] = evaluation2(contig_dict[gene], 0, {}, 0)
    loc_dict = {}
    p = [contig_dict[item]['bitscore'] for item in contig_dict]
    B_threshold = sum(p) * cont_bitscore
    B_max = sum(p)
    for cat in categories:
        types = [contig_dict[item][cat] for item in contig_dict]    
        for name in set(types):
            l = [contig_dict[item]['bitscore'] for item in contig_dict if (contig_dict[item][cat] == name and eval_dict[item][cat] == 1)]
            if sum(l) >= B_threshold:             
                loc_dict[cat] = name + ':' + str(round(sum(l)/B_max*100, 1))
    for cat in categories: 
        if not cat in loc_dict:
             loc_dict[cat] = "unclassified"      
    return(loc_dict) 

#Main function, contig classification for threshold < 50%                 
def classification_less(contig_dict):
    eval_dict = {}
    for gene in contig_dict:        
        eval_dict[gene] = evaluation2(contig_dict[gene], 0, {}, 0)
    loc_dict = {}
    p = [contig_dict[item]['bitscore'] for item in contig_dict]
    B_threshold = sum(p) * cont_bitscore
    B_max = sum(p)
    for cat in categories:
        types = [contig_dict[item][cat] for item in contig_dict]
        lu = []
        for name in set(types):
            l = [contig_dict[item]['bitscore'] for item in contig_dict if (contig_dict[item][cat] == name and eval_dict[item][cat] == 1)]
            if sum(l) >= B_threshold:
                p = name + ':' + str(round(sum(l)/B_max*100, 1))             
                lu.append(p)
        if len(lu) > 1:     
            loc_dict[cat] = ';'.join(lu)
        elif len(lu) == 1:
            loc_dict[cat] = str(lu).strip("['']")
    for cat in categories: 
        if not cat in loc_dict:
             loc_dict[cat] = "unclassified"      
    return(loc_dict) 
  

subprocess.call(['echo', '-e', '#Contig_ID\tNo_genes\tNo_annotated_genes\ttaxid_superkingdom:contribution\ttaxid_phylum:contribution\ttaxid_class:contribution\ttaxid_order:contribution\ttaxid_family:contribution\ttaxid_genus:contribution\ttaxid_species:contribution'], stdout=open(prefix + '_contigs_classification.txt','w'))


contigs_names2 = sorted(list(contigs_names))

file_out = open(prefix + '_contigs_classification.txt', 'a') 
               		            
print('Computation')
for contig in contigs_names2:
    gene_dict = main_dict[contig]
    contig_dict = {} 
#Evaluation of annotations per gene and analysing taxonomic 'level' of annotation       
    gene_dict_eval = {}
    for gene in gene_dict:
        gene_dict_eval[gene] = {}            
        if len(gene_dict[gene]['accessions']) > 1:
            for item in range(len(gene_dict[gene]['accessions'])):
                if taxonomy[gene_dict[gene]['accessions'][item]]:
                    gene_dict_eval[gene][gene_dict[gene]['accessions'][item]] = evaluation(gene_dict[gene]['accessions'][item], int(0), gene_dict[gene]['bitscores'][item], {}, 0)
                    contig_dict[gene] = calculation(gene_dict_eval[gene])
        elif len(gene_dict[gene]['accessions']) == 1 and taxonomy[gene_dict[gene]['accessions'][0]]:                                   
            gene_dict_eval[gene][gene_dict[gene]['accessions'][0]] = evaluation(gene_dict[gene]['accessions'][0], int(0), gene_dict[gene]['bitscores'][0], {}, 0)       
            loc_dict = {}
            for cat in categories:           
                if gene_dict_eval[gene][gene_dict[gene]['accessions'][0]][cat] != 0:
                    loc_dict[cat] = taxonomy[gene_dict[gene]['accessions'][0]][cat]
                       
                else:
                    loc_dict[cat] = "NA"
            loc_dict['bitscore'] = gene_dict_eval[gene][gene_dict[gene]['accessions'][0]]['root']
            contig_dict[gene] = loc_dict       
    number_genes_annotated = len(contig_dict)       
#Contig classification
    if cont_bitscore >= 0.5:
        contig_annot = classification_50(contig_dict)
        output = []
        output.append(contig)
        if mode_gff == 1:
            output.append(str(gff[contig]))
        elif mode_gff == 0:
            output.append('')
        output.append(str(number_genes_annotated))
        for cat in categories2:
            output.append(contig_annot[cat])
        file_out.write('\t'.join(output) + '\n')

    else:
        contig_annot = classification_less(contig_dict)
        output = []
        output.append(contig)
        if mode_gff == 1:
            output.append(str(gff[contig]))
        elif mode_gff == 0:
            output.append('')
        output.append(str(number_genes_annotated))

        for cat in categories2:
            output.append(contig_annot[cat])
        file_out.write('\t'.join(output) + '\n')

file_out.close()







