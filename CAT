#!/usr/bin/env python3

import csv
import subprocess
import sys
import re


#Paths to diamond, prodigal binaries and taxonomy files should be absolute.
path_to_diamond = '/absolute/path/to/diamond/binaries/'
path_to_prodigal = '/absolute/path/to/prodigal/binaries/'
path_to_taxonomy_files="/absolute/path/to/taxonomy/files/directory/"
#Optional, by providing the absolute path to database and database name below, there is no need to provide -db option
#For example like db='/home/dir1/dir2/database.dmnd'
db=''


error_message=" \n \
CAT v2.0 \n \
Written by Ksenia Arkhipova \n \
Last modified October 3, 2017 \n\n \
Description: CAT is a pipeline for robust taxonomic classification of long sequences. \n\n \
Usage: \n\n \
CAT <input file(s)> --prefix <uniq ID> [OTHER OPTIONS] \n\n \
Input options: \n\n \
Option 1: Including ORF prediction, alignment and sequence classification \n\n\
\t --fna \t FASTA_file.fna \t File with long sequences [nucleotides] \n\n\
\t --db \t diamond_database.dmnd \t Database with reference sequences. \n\n \
Option 2: Including alignment and sequence classification \n\n\
\t --faa \t FASTA_file.faa \t File with predicted protein sequences [proteins] \n\n \
\t --db \t diamond_database.dmnd \t Database with reference sequences. \n\n \
Option 3: Including sequence classification only.\n\n\
\t -d \t diamond_file \t File with alignment [m8] \n\n \
Other options: \n\n \
--threads \t NUMBER \t\t to set up the needed number of threads for diamond \n \
--sens \t\t\t\t to turn on --sensitive mode of diamond aligner \n \
--b1 \t\t bitscore 1 [0-100] \t Percentage range from highest bitscore for LCA identification of individual ORFs (Default:10) \n \
--b2 \t\t bitscore 2 [0-1] \t Cutoff for the maximum achievable bitscore for the contig (Defaul:0.5)\n \
--qual \t bitscore 3 [0-] \t Minimal alignment quality (bitscore value) which can be used in classification (Default:0) \n \
--no-lca-file \t\t\t\t Suppress output of file with LCA per ORF\n \
--no-summary-file \t\t\t Suppress output of summary file \n \
-h \t\t\t\t\t Print this message \n\n\
 If --b2 >= 0.5 the summary file will be generated, if --no-summary-file was not specified \n\n\
 To add additional information into output files (sum of proteins and contigs lengths, contribution of annotated ORFs, etc.) \n\
 CAT needs raw nucleotide and protein fasta files. They can be specified with \n\
 --fna (for contigs) and --faa (for proteins) options additionally. \n\
 Nucleotide fasta files could be provided for Options 2 and 3 and predicted proteins for Option 3.\n"


diamond = path_to_diamond + 'diamond'
prodigal = path_to_prodigal + 'prodigal'
protein_fasta = ''
mode = 0


if len(sys.argv) < 2 or "-h" in sys.argv:
    print("\n Please check that you provided --prefix and files for one of the input options")
    print(error_message)
    sys.exit() 

if '--prefix' in sys.argv:
    prefix = sys.argv[(sys.argv).index("--prefix")+1]
    diamond_file = prefix + '_alignment_diamond'
else:
    print('\n Prefix is missing', error_message, sep='\n')
    sys.exit()

if '--db' in sys.argv:
    database_name=sys.argv[(sys.argv).index("--db")+1]
    database = re.search('(.*)\.dmnd', database_name).group(1)
else:
    database = db        

if "-d" in sys.argv:
    diamond_file=sys.argv[(sys.argv).index("-d")+1]
    if '--faa' in sys.argv:
        protein_fasta = sys.argv[(sys.argv).index("--faa")+1]
    if '--fna' in sys.argv:
        fasta=sys.argv[(sys.argv).index("--fna")+1]
    mode = 2
elif "--fna" in sys.argv and "-d" not in sys.argv and '--faa' not in sys.argv:    
    fasta=sys.argv[(sys.argv).index("--fna")+1]
elif '--faa' in sys.argv and "-d" not in sys.argv:
    protein_fasta=sys.argv[(sys.argv).index("--faa")+1]
    diamond_file = prefix + '_alignment_diamond'
    mode = 1    
else:    
    print("Input fasta file is missing")
    print(error_message)
    sys.exit()

if "--b1" in sys.argv:
  b1=sys.argv[(sys.argv).index("--b1")+1]
  cust_bit_thresh=1 - float(b1)/float(100)
else:
  cust_bit_thresh=0.9

if "--b2" in sys.argv:
  cont_bitscore=float(sys.argv[(sys.argv).index("--b2")+1])
else:
  cont_bitscore=0.5

if '--qual' in sys.argv:
    qual_threshold=float(sys.argv[(sys.argv).index("--qual")+1])
else:
    qual_threshold = 0

if mode == 0:
    print('Predicting ORFs')
    protein_gff = prefix + '_orfs.gff'
    protein_fasta = prefix + '_predicted_prot.faa'
    subprocess.check_call([prodigal, '-i', fasta, '-a', protein_fasta, '-o', protein_gff, '-p', 'meta', '-q', '-f', 'gff'])
    mode = 1
if mode == 1:
    print('Aligning')
    try:
        if '--sens' in sys.argv:
            if '--threads' in sys.argv:
                subprocess.check_call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '--sensitive', '-p', sys.argv[(sys.argv).index("--threads")+1], '-o', diamond_file, '--quiet'])
            else:
                subprocess.check_call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '--sensitive', '-o', diamond_file, '--quiet'])
        else:
            if '--threads' in sys.argv:
                subprocess.check_call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '-p', sys.argv[(sys.argv).index("--threads")+1], '-o', diamond_file, '--quiet'])
            else:
                subprocess.check_call([diamond, 'blastp', '-d', database, '-q', protein_fasta, '-o', diamond_file, '--quiet'])
    except subprocess.CalledProcessError:
        print('Please check path to diamond, presence information about database location or fasta file with coded proteins')
        sys.exit()
elif mode == 2:     
    pass

sub = {'A' : 4, 'R' : 5, 'D' : 6, 'N' : 6, 'C' : 9, 'E' : 5, 'Q' : 5, 'G' : 6, 'H' : 8, 'I' : 4, 'L' : 4, 'K' : 5, 'M' : 5, 'F' : 6, 'P' : 7, 'S' : 4, 'T' : 5, 'W' : 11, 'Y' : 7, 'V' : 4, '*' : 1, 'X' : -1, 'B' : 4, 'J' : 3, 'Z' : 4}

categories2 = ["superkingdom","phylum","class","order","family","genus","species"]
categories = ["species", "genus", "family", "order", "class", "phylum", "superkingdom", 'root']

#Parsing of NCBI taxonomy files
names_dict = {}
rank_dict = {}
parent_dict = {}
with open(path_to_taxonomy_files + 'names.dmp') as names_file:
    names = csv.reader(names_file,delimiter='\t',quoting=csv.QUOTE_NONE)     
    for line in names:
        if line[6] == 'scientific name':
            names_dict[line[0]] = line[2]

with open(path_to_taxonomy_files + 'nodes.dmp','r')as nodes_file:
    nodes = csv.reader(nodes_file,delimiter='\t',quoting=csv.QUOTE_NONE)
    for line in nodes:
        parent_dict[line[0]] = line[2]
        rank_dict[line[0]] = line[4]

def parse_nodes(taxid, data_dict):
    if taxid in parent_dict and taxid in rank_dict:
        while parent_dict[taxid] != taxid:
            data_dict[rank_dict[taxid]] = taxid + '_' + names_dict[taxid]
            taxid = parent_dict[taxid]
    else:
          data_dict = {}  
    return(data_dict)


#Parsing of alignment file
print('Parsing diamond alignment')
contigs_names = set()
main_dict = {}
with open(diamond_file) as file_1:
    alignment=csv.reader(file_1,delimiter='\t')
    taxonomy = {}
    for line in alignment:
        without_version = re.search('^(.+?)(?=(\.|:|$))', line[1]).group(1)
        if len(without_version) > 15:
            continue
        contig_name = re.search('(.*)_\d+$', line[0]).group(1)
        gene_name = line[0]
        contigs_names.add(contig_name)
        if without_version not in taxonomy:
            taxonomy[without_version] = {}
        if contig_name not in main_dict:
            main_dict[contig_name] = {}   
        if gene_name not in main_dict[contig_name] and float(line[-1]) > qual_threshold:
            main_dict[contig_name][gene_name] = {}
            main_dict[contig_name][gene_name]['accessions'] = [without_version]
            main_dict[contig_name][gene_name]['bitscores'] = [float(line[-1])]
            bit_threshold = float(line[-1]) * cust_bit_thresh
        elif gene_name in main_dict[contig_name] and float(line[-1]) > bit_threshold and float(line[-1]) > qual_threshold:            
            main_dict[contig_name][gene_name]['accessions'].append(without_version)
            main_dict[contig_name][gene_name]['bitscores'].append(float(line[-1]))

all_cont_names = {}
# Calculate artificial bitscore for each predicted protein
if protein_fasta:
    gff = {}
    print('Parsing protein fasta')
    art_score = {}
    for w in main_dict:
        art_score[w] = {}
        gff[w] = 0 
    score = []
    art_cont = ''
    with open(protein_fasta) as file1:
        for line in file1:        
            if line.startswith('>'): 
                if art_cont in art_score:                                       
                    art_score[art_cont][art_gene] = sum(score)
                    gff[art_cont] += 1
                art_gene = re.search('^>(\S+)\s', line).group(1)
                art_cont = re.search('^>(\S+)_\d+\s', line).group(1)
                all_cont_names[art_cont] = ''
                score = []            
            elif not line.startswith('>'):
                r = 0
                for let in line.strip():
                    if let in sub:
                        r += sub[let]
                    else:   
                        print(let)
                score.append(r)
        if art_cont in art_score:  
            art_score[art_cont][art_gene] = sum(score)

#Collecting links between accession numbers and taxids
print('Parsing prot.accession2taxid file')	
with open(path_to_taxonomy_files + 'prot.accession2taxid') as file1:
    acc_tax_csv=csv.reader(file1,delimiter='\t',quoting=csv.QUOTE_NONE)
    for line in acc_tax_csv:        
        if line[0] != 'accession':
            if line[0] in taxonomy:
                z = parse_nodes(line[2], {})
                if z:
                    for cat in categories:
                        if cat in z.keys():
                            taxonomy[line[0]][cat] = z[cat] 
                        else:
                            taxonomy[line[0]][cat] = 'NA'
                else:
                    for cat in categories:
                        taxonomy[line[0]][cat] = 'NA'
                taxonomy[line[0]]['root'] = '131567_cellular organisms'


if '--fna' in sys.argv and cont_bitscore >= 0.5:
    print("Collecting contigs length info")
    contig_length = {}
    contig = ''
    with open(fasta) as file8:
        for line in file8:
            if line.startswith('>'):
                if contig:                                       
                    contig_length[contig] = r
                r = 0   
                contig = re.search('^>(\S+)$', line).group(1)          
            elif not line.startswith('>'):
                r += len(line.strip())
        contig_length[contig] = r


#The function evaluates level of taxonomic annotation for N% top hits for a gene to exclude bitscores 
#of low-level annotations and retain it in case of accidental absence of annotation

#For example "species", "genus", "family", "order", "class", "phylum", "superkingdom"
#               exist    exist       NA     exist    exist    exist     exist
#bitscore for NA will be accounted for
#For example "species", "genus", "family", "order", "class", "phylum", "superkingdom"
#               NA        NA       NA       exist     exist    exist     exist
#In this case bitscores for NA will be excluded

def evaluation(acc, index, bitscore, gene_dict, flag):
    if index < 8:
        if taxonomy[acc][categories[index]] == 'NA' and flag == 0:
            gene_dict[categories[index]] = 0
            index += 1
            return(evaluation(acc, index, bitscore, gene_dict, flag))
        elif taxonomy[acc][categories[index]] == 'NA' and flag == 1:
            gene_dict[categories[index]] = bitscore
            index += 1
            return(evaluation(acc, index, bitscore, gene_dict, flag))   
        else:
            gene_dict[categories[index]] = bitscore
            index += 1
            flag = 1 
            return(evaluation(acc, index, bitscore, gene_dict, flag))   
    else:
        return(gene_dict)


#Same function as previous, but for analysis of gene annotation after identification of LCA
def evaluation2(genes, index, gene_dict, flag):
    if index < 8:
        if genes[categories[index]] == 'NA' and flag == 0:
            gene_dict[categories[index]] = 0
            index += 1
            return(evaluation2(genes, index, gene_dict, flag))
        elif genes[categories[index]] == 'NA' and flag == 1:
            gene_dict[categories[index]] = 1
            index += 1
            return(evaluation2(genes, index, gene_dict, flag)) 
        else:
            gene_dict[categories[index]] = 1
            index += 1
            flag = 1 
            return(evaluation2(genes, index, gene_dict, flag))   
    else:
        return(gene_dict)

#Identification of LCA for N% of top hits
def calculation(eval_dict, contig):
    lca = ''   
    loc_dict = {}

    for cat in categories:
        if [taxonomy[item][cat] for item in eval_dict if eval_dict[item][cat] != 0]:
            l, num = zip(*[(taxonomy[item][cat], item) for item in eval_dict if eval_dict[item][cat] != 0])
            if len(set(l)) == 1 and l[0] != 'NA':
                lca  = cat
                b = [eval_dict[item][cat] for item in eval_dict if eval_dict[item][cat] != 0]
                bitscore = sum(b) / len(num)
                break
    
    for i in range(8):
        if i >= categories.index(lca):
            loc_dict[categories[i]] = taxonomy[num[0]][categories[i]]
        else:
            loc_dict[categories[i]] = 'NA'    
    loc_dict["bitscore"] = bitscore 
    return(loc_dict)

#Main function, contig classification for threshold >= 50%         
def classification_50(contig_dict):
    eval_dict = {}
    for gene in contig_dict:        
        eval_dict[gene] = evaluation2(contig_dict[gene], 0, {}, 0)
    loc_dict = {}
    loc_dict_2 = {}
    p = [contig_dict[item]['bitscore'] for item in contig_dict]
    B_threshold = sum(p) * cont_bitscore
    B_max = sum(p)
    for cat in categories:
        types = [contig_dict[item][cat] for item in contig_dict]    
        for name in set(types):
            l = [contig_dict[item]['bitscore'] for item in contig_dict if (contig_dict[item][cat] == name and eval_dict[item][cat] == 1)]
            if sum(l) >= B_threshold:             
                loc_dict[cat] = name + ':' + str(round(sum(l)/B_max*100, 1))
                loc_dict_2[cat] = name
    for cat in categories: 
        if not cat in loc_dict:
            loc_dict[cat] = "unclassified"
            loc_dict_2[cat] = "unclassified"      
    return(loc_dict, loc_dict_2) 

#Main function, contig classification for threshold < 50%                 
def classification_less(contig_dict):
    eval_dict = {}
    for gene in contig_dict:        
        eval_dict[gene] = evaluation2(contig_dict[gene], 0, {}, 0)
    loc_dict = {}
    p = [contig_dict[item]['bitscore'] for item in contig_dict]
    B_threshold = sum(p) * cont_bitscore
    B_max = sum(p)
    for cat in categories:
        types = [contig_dict[item][cat] for item in contig_dict]
        lu = []
        for name in set(types):
            l = [contig_dict[item]['bitscore'] for item in contig_dict if (contig_dict[item][cat] == name and eval_dict[item][cat] == 1)]
            if sum(l) >= B_threshold:
                p = name + ':' + str(round(sum(l)/B_max*100, 1))             
                lu.append(p)
        if len(lu) > 1:     
            loc_dict[cat] = ';'.join(lu)
        elif len(lu) == 1:
            loc_dict[cat] = str(lu).strip("['']")
    for cat in categories: 
        if not cat in loc_dict:
             loc_dict[cat] = "unclassified"      
    return(loc_dict) 
  

subprocess.call(['echo', '-e', '#Contig_ID\tNo_genes\tNo_annotated_genes\tContribution_of_annotated_ORFs\ttaxid_superkingdom:contribution\ttaxid_phylum:contribution\ttaxid_class:contribution\ttaxid_order:contribution\ttaxid_family:contribution\ttaxid_genus:contribution\ttaxid_species:contribution'], stdout=open(prefix + '_contigs_classification.txt','w'))

if not '--no-lca-file' in sys.argv:
    subprocess.call(['echo', '-e', '#Contig_ID\tAverage_bitscore\ttaxid_superkingdom\ttaxid_phylum\ttaxid_class\ttaxid_order\ttaxid_family\ttaxid_genus\ttaxid_species'], stdout=open(prefix + '_LCA_per_ORF.txt','w'))
    out_orf = open(prefix + '_LCA_per_ORF.txt', 'a')
#Calculate contribution of annotated ORFs to taxonomic classification 
def weights_comp(contig, contig_dict):
    Art_Bmax = 0
    Art_Bann = 0
    for scaf in art_score[contig]:
        Art_Bmax += art_score[contig][scaf]
    for genes in contig_dict:
        Art_Bann += art_score[contig][genes]
    return(str(round(Art_Bann / Art_Bmax * 100, 2)))

contigs_names2 = sorted(list(contigs_names))

file_out = open(prefix + '_contigs_classification.txt', 'a') 

summary = {}
for cat in categories:
    summary[cat] = {}
               		            
print('Computation')
for contig in contigs_names2:
    gene_dict = main_dict[contig]
    contig_dict = {} 
#Evaluation of annotations per gene and analysing taxonomic 'level' of annotation       
    gene_dict_eval = {}
    for gene in gene_dict:
        gene_dict_eval[gene] = {}            
        if len(gene_dict[gene]['accessions']) > 1:
            for item in range(len(gene_dict[gene]['accessions'])):
                if taxonomy[gene_dict[gene]['accessions'][item]]:
                    gene_dict_eval[gene][gene_dict[gene]['accessions'][item]] = evaluation(gene_dict[gene]['accessions'][item], int(0), gene_dict[gene]['bitscores'][item], {}, 0)
            if not gene_dict_eval[gene]:
                gene_dict_eval.pop(gene, None)
            else:        
                contig_dict[gene] = calculation(gene_dict_eval[gene], contig)
        elif len(gene_dict[gene]['accessions']) == 1 and taxonomy[gene_dict[gene]['accessions'][0]]:                                   
            gene_dict_eval[gene][gene_dict[gene]['accessions'][0]] = evaluation(gene_dict[gene]['accessions'][0], int(0), gene_dict[gene]['bitscores'][0], {}, 0)       
            loc_dict = {}
            for cat in categories:           
                if gene_dict_eval[gene][gene_dict[gene]['accessions'][0]][cat] != 0:
                    loc_dict[cat] = taxonomy[gene_dict[gene]['accessions'][0]][cat]                       
                else:
                    loc_dict[cat] = "NA"
            loc_dict['bitscore'] = gene_dict_eval[gene][gene_dict[gene]['accessions'][0]]['root']
            contig_dict[gene] = loc_dict       
    number_genes_annotated = len(contig_dict)
    if number_genes_annotated > 0 and not '--no-lca-file' in sys.argv:
        for contig_orf in sorted(contig_dict):
            loc_list = []
            loc_flag = 0
            for cat in categories[:-1]:
                if contig_dict[contig_orf][cat] == 'NA' and loc_flag == 0:
                    loc_list.append('unclassified')
                elif contig_dict[contig_orf][cat] == 'NA' and loc_flag == 1:
                    loc_list.append('NA')
                else:
                    loc_list.append(contig_dict[contig_orf][cat])
                    loc_flag = 1
            loc_list = loc_list[::-1]
            loc_list.insert(0, str(round(contig_dict[contig_orf]['bitscore'], 2)))
            loc_list.insert(0, contig_orf)
            out_orf.write('\t'.join(loc_list) + '\n')

#Contig classification
    if cont_bitscore >= 0.5 and contig_dict:
        contig_annot, contig_annot2 = classification_50(contig_dict)
        output = []
        output.append(contig)
        if protein_fasta:
            output.append(str(gff[contig]))
            weight = weights_comp(contig, contig_dict)
            output.append(weight)
        else:
            output.append('')
            output.append('')
        output.append(str(number_genes_annotated))
        for cat in categories2:
            if contig_annot2[cat] in summary[cat]:
                summary[cat][contig_annot2[cat]][0] += 1
                if protein_fasta:
                    summary[cat][contig_annot2[cat]][1] += gff[contig]
                if '--fna' in sys.argv:
                    summary[cat][contig_annot2[cat]][2] += contig_length[contig]
            else:
                summary[cat][contig_annot2[cat]] = [0, 0, 0]
                summary[cat][contig_annot2[cat]][0] = 1
                if protein_fasta:
                    summary[cat][contig_annot2[cat]][1] += gff[contig]
                if '--fna' in sys.argv:
                    summary[cat][contig_annot2[cat]][2] += contig_length[contig]
            output.append(contig_annot[cat])
        file_out.write('\t'.join(output) + '\n')
    elif cont_bitscore < 0.5 and contig_dict:
        contig_annot = classification_less(contig_dict)
        output = []
        output.append(contig)
        if protein_fasta:
            output.append(str(gff[contig]))
            weight = weights_comp(contig, contig_dict)
            output.append(weight)
        else:
            output.append('')
            output.append('')
        output.append(str(number_genes_annotated))
        for cat in categories2:
            output.append(contig_annot[cat])
        file_out.write('\t'.join(output) + '\n')
    else:
        file_out.write(contig + '\tNo hits' + '\n')
if all_cont_names:
    for contig in all_cont_names:
        if contig not in main_dict:
            file_out.write(contig + '\tNo hits' + '\n') 
file_out.close()
if not '--no-lca-file' in sys.argv:
    out_orf.close()
#Generation of summary file
print("Let's summarise...")
if cont_bitscore >= 0.5 and not '--no-summary-file' in sys.argv:                   
    with open(prefix + '_summary.txt', 'w') as file7:
        file7.write('#Total number of contigs is ' + str(len(contigs_names)) + '\n')
        file7.write('#Classification_level' + '\t' + 'Taxon_name' + '\t' + 'Number_of_contigs' + '\t' + 'Sum_number_of_proteins' + '\t' + 'Sum_length_of_contigs' + '\n')
        for cat in categories2:  
            sum_tot = []      
            for item in summary[cat]:
                l = [cat, item, summary[cat][item][0], summary[cat][item][1], summary[cat][item][2]]
                sum_tot.append(l)
            total = sorted(sum_tot, key=lambda x: x[2], reverse=True)
            for item in total:
                file7.write('\t'.join([str(x) for x in item]) + '\n')






